



nmap -A -sC : active the Nmap Scripting engine


MAC Flood
Switch is flooded with MAC address and turned into a hub.
Content Address Memory is overflood
Macof can achieve it.
Mitigating it by configure port security. Allow MAC address to be specified on a particular port or specify the max number of addresses the switchport can learn.
IP Fragment
Dumpster Diving

SPAN port: send a copy of all frames from one port in switch to another. Also called port mirroring.

SHA-1 use 160 bits encryption.

AES: 128, 192, 256 bit key.
RC5:128-bit key
3DES: 168-bits

WPA use TKIP. 
WPA2 use AES with CCMP( Cipher Block Chain).

Authentication Header (AH) is used by IPsec.

Kerberos protocol port: 88

syslog daemon default listen:

tailgating: attacker has a fake id and follow an authorized person through the opened security door.
piggybacking: attacker doesn't have a badge but ask for someone let her in any way.

syskey use 128–bit encryption.

SNMP port: 161
syslog: UDP 514, TCP 1468
TFTP:
NTP: UDP 123

WEP:
64-bit version use 40-bit key
128-bit use 104-bit key
256-bit use 232-bit key

Pcap is used by Nmap, Snort and Tcpdump, and libpcap is a version of Pcap, written by C/C++ and used on Unix-like systems.

IEEE 802.1X standard defines a method that use Extensible Authentication Protocol (EAP) to establish port-based Network Access Control (NAC). IEEE 802.1X is designed to require authentication before a client is allowed access to a network.

Advanced Encryption Standard (AES) used in Wi-Fi Protected Access 2 (WPA2).

Layer 2 Tunnelling Protocol (L2TP) can be used to establish VPN connections. IPSec can be used to encrypt L2TP traffic.

cross-certificate trust model is a method of federated identity management.
trusted third-party model is also know as the bridge model, and is a method of federated identity management. It uses a single organization to manage the authentication.

single sing-on(SSO) model is not a federated identity management model. Such as Kerberos and Secure European System for Applications in a Multi-vendor Environment (SESAME) use one credential over a given period time.

fget() is a C library function that performs bounds checking on its input.

smtp use TCP 25.
POP3 use TCP 110.
printer: TCP 631

Business continuity plan (BCP) contains procedures that should performed in the event of a disaster.

Cross-Site Request Forgery (CSRF) attacks can be mitigated by configuring a Web server to send random challenge tokens.
Cross-site scripting (XSS) attacks can be  mitigated by configuring a Web server to sent HttpOnly flag in cookies.

SOAP messages are typically one-way transmissions and is capable with HTTP and SMTP. Service Oriented Architectures (SOAs) using SOAP. SOAP is maintained by W3C.

 A router, firewall, and a wireless access point (WAP) can be used as a gateway. A gateway is a device that routes traffic between disparate networks. 

The -P0 parameter configures Nmap to scan hosts that do not respond to Internet Control Message Protocol (ICMP) pings. By default, Nmap will not scan hosts that do not reply to pings, the -P0 parameter disables ICMP pings and skips the initial ICMP ping check, which is useful when performing stealth scan in order to avoid detection.

Microsoft Baseline Security Analyzer (MBSA) utility to determine whether Window-based computer have the most recent updates.

Kismet is used to scam wireless network. It can also used as an intrusion detection system. Support 802.11a/b/g/n. Support monitor mode.
NetStumbler cam scan wireless network but only on windows-based computer, support only 802.11a/b/g networks and does not support monitor mode.

Nikto is an open-source Web server scanner that tests for dangerous files, outdated server software and other Web server vulnerabilities.
Paros Proxy can crawl a Web site and execute vulnerability tests, including fuzzing.

stateful firewall allow traffic into a network only if a corresponding request was send from inside the network. Stateful firewalls and packet filter firewalls operate at the Network layer and transport layer of the OSI model.

ISO 27002 is a security standard that recommends security control based on industry best practices.
ISO 27001 focuses on security governance.
PCI DSS is a security evaluation standard that was PCI SSC (Security Standards Council). PCI DSS focuses on protection customer data by using secure networks, manage vulnerabilities, implement strong methods of access control, implementing network security tests and monitoring, and maintaining a security policy.

A man trap is a security measure that can be used to  limit a company’s vulnerability to tailgating. 

Dynamic Network Address Translation (NAT) uses a many-to-many mapping. 
Port Address Translate (PAT) uses a  magnet one mapping to translate multiple private IP address to a single public IP address, which is also referred as Network Address Translation overload. 

Bluetooth 2.0 with Enhanced Data Rate (EDR) uses two types of phase-shift keying (PSK) digital modulation: p/4-DQPSK and 8DPSK.

DH Group 14 uses a 2048-bit modules.

Smurf is a DoS attack by using ICMP echo request.
Fraggle is a Dos attack by using UDP echo and Chargen packets, and send out the packet to broadcast address with a spoofed source IP.
Local Area Network Denial ((LAND) is a Dos by using malformed IP packet with same source and destination address.
Teardrop is a Dos by using several large overlapping IP fragments. 

hing2
default: TCP
-0 --rawip
RAW IP mode, in this mode hping2 will send IP header with data appended with --signature and/or --file, see also --ipproto that allows you to set the ip protocol field.
-1 --icmp
ICMP mode, by default hping2 will send ICMP echo-request, you can set other ICMP type/code using --icmptype --icmpcode options.
-2 --udp
UDP mode, by default hping2 will send udp to target host's port 0. UDP header tunable options are the following: --baseport, --destport, --keep.
-8 --scan

255.255.255.255 is a layer 3 limited broadcast address. Packet is sent to all devices on a broadcast domain.
198.168.0.255 is a layer 3 directed broadcast address. Packet is send to all devices on 192.168.0.0/24
FF:FF:FF:FF:FF:FF is a layer 2 Ethernet broadcast address. Broadcast is send to al nodes on a switch but not forwarded by routers.

Border Gateway Protocol (BGP) is a routing protocol. Other routing protocols include Enhanced Interior Gateway Routing Protocol (EIGRP), Routing Information Protocol (RIP), Intermediate System-to-Intermediate system (IS-IS), and Open Shortest Path First (OSPF).

sc query : active service in windows server 2012
sc query state=inactive/all
sc query type=driver

The purpose of key escrow is to enable a trusted third party to access sensitive data if the need arises.

Open Source Security Testing Methodology Manual (OSSTMM):
Class A - Interactive Controls: Authentication, Identification, resilience, Subjugation, Continuity
Class B - Process Controls: Nonrepudiation, Confidentiality, Privacy, Integrity, Alarm

Port Security authorizes traffic send form specified Media Access Control (MAC) addresses to enter a port. 
---------------------------------------------------------------

Chapter 2

Some tools available to help in this regard are the National Vulnerability Database (nvd.nist.gov), Securitytracker (www.security- tracker.com), Hackerstorm Vulnerability Database Tool (www.hackerstrom.com), and SecurityFocus (www.securityfocus.com).

Footprinting is defined as the process of gathering information on computer sys- tems and networks. It is the first step in information gathering and provides a high- level blueprint of the target system or network. Footprinting follows a logical flow— investigating web resources and competitive intelligence, mapping out network ranges, mining whois and DNS, and finishing up with social engineering, e-mail tracking, and Google hacking.

 
Competitive intelligence refers to the information gathered by a business entity about its competitors’ customers, products, and marketing. Most of this information is readily available and is perfectly legal for you to pursue and acquire. Competitive intelligence tools include Google Alerts, Yahoo! Site Explorer, SEO for Firefox, SpyFu, Quarkbase, and DomainTools.com.
DNS provides ample opportunity for footprinting. DNS consists of servers all over the world, with each server holding and managing records for its own namespace. DNS lookups generally use UDP port 53, whereas zone transfers use TCP 53. Each of these records gives directions to or for a specific type of resource. DNS records are as follows:
SRV (Service) Defines the hostname and port number of servers providing specific services, such as a Directory Services server.
SOA (Start of Authority) Identifies the primary name server for the zone. The SOA record contains the hostname of the server responsible for all DNS records within the namespace, as well as the basic properties of the domain.
PTR (Pointer) Maps an IP address to a hostname (providing for reverse DNS lookups).
NS (Name Server) Defines the name servers within your namespace.
MX (Mail Exchange) Identifies the e-mail servers within your domain.
CNAME (Canonical Name) Provides for domain name aliases within your zone.
A (Address) Maps an IP address to a hostname and is used most often for DNS lookups.
The SOA record provides information on source host (hostname of the SOA server), contact e-mail (e-mail address of the person responsible for the zone file), serial num- ber (revision number of the zone file), refresh time (the number of seconds a secondary DNS server will wait before asking for updates), retry time (the number of seconds a secondary server will wait to retry if the zone transfer fails), expire time (the maximum number of seconds a secondary server will spend trying to complete a zone transfer), and TTL (the minimum time to live for all records in the zone).
DNS information for footprinting can also be garnered through the use of whois, which originally started in Unix and has generated any number of websites set up spe- cifically for its purpose. It queries the registries and returns all sorts of information, including domain ownership, addresses, locations, and phone numbers. Well-known websites for DNS or whois footprinting include www.geektools.com, www.dnsstuff. com, and www.samspade.com.
The nslookup command is part of virtually every operating system in the world and provides a means to query DNS servers for information. The syntax for the tool is as follows:
nslookup [-options] {hostname | [-server]}The command can be run as a single instance, providing information based on the options you choose, or you can run it in interactive mode, where the command runs as a tool, awaiting input from you. The command can also provide for a zone transfer, using ls -d. A zone transfer differs from a “normal” DNS request in that it pulls every record from the DNS server instead of just the one, or one type, you’re looking for.

Native to Unix systems but available as a download for Windows systems (along with BIND 9), dig is another tool used to test a DNS query and report the results. The basic syntax for the command is
dig @server name type
where server is the name or IP of the DNS name server, name is the name of the resource you’re looking for, and type is the type of record you want to pull.
Determining network range is another important footprinting task for the ethical hacker. If you simply enter an IP address in www.arin.net, the network range will be shown. Additionally, traceroute (or tracert hostname on Windows systems) is a command-line tool that tracks a packet across the Internet and provides the route path and transit times. McAfee’s Visual Trace (NeoTrace to some), Trout, and VisualRoute are all examples of applications that use this information to build a visual map, showing geographical locations as well as technical data.

Chap 3

EC-Council’s scanning methodology phases include the following: check for live systems, check for open ports, scan beyond IDS, perform banner grabbing, scan for vulnerabilities, draw network diagrams, and prepare proxies.
Examples of protocols making use of UDP are TFTP, DNS, and DHCP.
Six flags can be set in the TCP header: URG (Urgent), ACK (Acknowledgment), PSH (Push), RST (Reset), SYN (Synchronize), and FIN (Fin- ish).
The port numbers range from 0 to 65,535 and are split into three different groups: Well-known (0–1023), Registered (1024–49151), and Dynamic (49152–65535). A system is said to be listening for a port when it has that port open. Typing netstat -an displays all connections and listening ports, with addresses and port numbers in numerical form.
A ping sweep is the easiest method for identifying active machines on the network. An ICMP Echo Request (Type 8) message is sent to each address on the subnet. Those that are up (and not filtering ICMP) reply with an ICMP Echo Reply (Type 0). Several tools can provide for ping sweeps; Angry IP Scanner, Pinger, WS_Ping, SuperScan, and Friendly Pinger are all examples.

nmap <scan options> <target>
The “s” commands determine the type of scan to perform, the “P” commands set up ping sweep options, and the “o” commands deal with output. The “T” commands deal with speed and stealth, with the serial methods taking the longest amount of time. Parallel methods are much faster because they run multiple scans simultaneously. Nmap switches you’ll definitely see on the exam are -sS (SYN scan), -sA (ACK scan), -sO (protocol scan), -sX (XMAS scan), and all of the “T” commands.
There are seven generic scan types for port scanning. TCP Connect scans run through a full connection (three-way handshake) on all ports. They are the easiest to detect but definitely the most reliable. Open ports will respond with a SYN/ACK, and closed ports will respond with an RST/ACK. SYN scans are known as half-open scans, with only SYN packets sent to ports (no completion of the three-way handshake ever takes place) and are easily detected by IDS. Responses from ports are the same as they are for a TCP Con- nect scan. FIN scans run the communications setup in reverse, sending a packet with the FIN flag set. Closed ports respond with RST, whereas open ports won’t respond at all. XMAS scans send multiple flags set (FIN, URG, and PSH). Port responses are the same as with a FIN scan. ACK scans are used mainly for Unix/Linux-based systems and make use of ICMP destination unreachable messages to determine what ports may be open on a firewall. IDLE scans use a spoofed IP address to elicit port responses during a scan. Designed for stealth, this scan uses a SYN flag and monitors responses as with a SYN scan. Finally, NULL scans send packets with no flags set. Responses will vary, depending on the OS and version, but NULL scans are designed for Unix/Linux machines.
War dialing is a process by which an attacker dials a set of phone numbers specifi- cally looking for an open modem. As you know, modems are designed to answer the call, and they can easily provide back-door access to a system otherwise completely secured from attack. Tools for accomplishing war dialing are ToneLoc, THC-Scan, WarVox (designed explicitly for VoIP systems), PAWS, and TeleSweep.
War driving used to refer to driving around in a car looking for open access points. In the ethical hacking realm, it still indicates a search for open WAPs; however, with the proliferation of handheld devices making use of 802.11 wireless standards, finding access points is as easy as simply wandering around the facility. Additionally, several tools are available to help you not only in discovering wireless entry points but in find- ing vulnerabilities in wireless networking. Silica, AirMagnet, and AirCheck (Fluke) are all tools on handheld devices that allow an attacker to walk around and gather—and sometimes even exploit—wireless access point vulnerabilities.

Hiding your activities from prying security-professional eyes can be done using a proxy, spoofing an IP address, using source routing, or using an anonymizer. A proxy server is nothing more than a system you set up to act as an intermediary between you and your targets. The hacker sends commands and requests to the proxy, and the proxy relays them to the targets. Anyone monitoring the subnet sees the proxy trying all this naughtiness, not the hacker. Spoofing an IP address is exactly what it sounds like—the hacker uses a packet-crafting tool of some sort to obscure the source IP address of pack- ets sent from his machine. There are many tools available for this, such as hping, Scapy, and Nemesis.

ource routing provides yet another means to disguise your identity on a network. It was originally designed to allow applications to specify the route a packet would take to a destination, regardless of what the route tables between the two systems said. The attacker can use an IP address of another machine on the subnet and have all the return traffic sent back regardless of which routers are in transit. Protections against source- routing attacks are prevalent and effective in modern systems, so this may not be your best option. Another easy method for disguising your identity for port 80 (HTTP) traffic is to use an anonymizer. Anonymizers are services on the Internet that use a web proxy to hide your identity.
When we enumerate a target, we’re moving from passive information gathering to a much more active state. No longer satisfied with just knowing which ports are open, we now want to find things such as open shares and any easy-to-grab user account information.
Microsoft Windows machines—everything from old Windows 2000 to Windows 7 systems—will constitute the vast majority of your targets in the real world, so it’s important to know some security basics before enumerating them. User rights are granted via an account’s membership within a group and determine which system tasks an account is allowed to perform. Permissions are used to determine which resources an account has access to. The method by which Windows keeps track of which account holds what rights and permissions comes down to SIDs and RIDs. A security identifier (SID) identifies user, group, and computer accounts and follows a specific format. A resource identifier (RID) is a portion of the overall SID identifying a specific user, com- puter, or domain.
SIDs are composed of an S, followed by a revision number, an authority value, a domain or computer indicator, and a RID. The RID portion of the identifier starts at 500 for the administrator account. The next account on the system, Guest, is RID 501. All users created for the system start at 1000 and increment from that point forward— even if their usernames are re-created later.
Accounts are identified by their SID (and associated RID), of course, but the pass- words for them must be stored somewhere, too. In Windows, passwords are stored in C:\Windows\System 32\Config\SAM. The SAM database holds encrypted versions of all the local passwords for accounts on the machine. For those machines that are part of a domain, the passwords are stored and handled by the domain controller.
A null session occurs when you log in to a system with no user ID and password at all. In older Windows versions (Windows 2000), a null session could be set up using the following command:
net use \\<target>\IPC$ "" /u:""
Null sessions require TCP ports 135, 137, 139, and 445 to work and have been virtu- ally eliminated from the hacking arsenal since Windows XP was released.

Linux systems use a user ID (UID) and a group ID (GID) in much the same way as Windows uses SIDs and RIDs. On a Linux machine, these can be found in the /etc/ passwd file.

Banner grabbing is one of the easiest enumerating methods and involves sending an unsolicited request to an open port to see what, if any, default error message (ban- ner) is returned. Depending on what version of application is running on the port, the returned banner can indicate a potential vulnerability for the hacker to exploit. A com- mon method of performing banner grabbing is to use Telnet aimed at a specific port. For example, to banner-grab from a suspected web server, typing telnet <IPAddress> 80 would attempt a connection over port 80.
Another tool for banner grabbing (and other uses) is netcat. Known as the “Swiss Army knife of hacking tools,“ netcat is a command-line networking utility that reads and writes data across network connections using TCP/IP. It’s also a tunneling protocol, a scanner, and an advanced hacking tool. To try banner grabbing with this little jewel, simply type nc <IPaddress or FQDN> <port number>.

SNMP enumeration may also prove useful. SNMP uses a community string as a form of password, with the read-only version of the community string allowing a requester to read virtually anything SNMP can drag out of the device. The read-write version is used to control access for SNMP SET requests, which can actually change settings on a device. The defaults for both of these strings are public (read-only) and private (read- write). Assuming the network administrator left SNMP enabled and/or did not change the default strings, enumerating with SNMP is relatively easy, and tools for accomplish- ing this are SNMPUtil and IP Network Browser (SolarWinds).


Chapter 4

Sniffing (sometimes known as wiretapping by law enforcement types) is the art of capturing packets as they pass on a wire, or over the airwaves, to review for interesting information. The process of sniffing comes down to a few items of great importance: what state the NIC is in, what wire you have access to, and what tool you’re running. A sniffer runs in promiscuous mode. Regardless of address, if the frame is passing on the wire, the sniffer tells the NIC to grab it and pull it in. WinPcap is an example of a driver that allows the operating system to provide low-level network access and is used by a lot of sniffers on Windows machine NICs. Libpcap is the Linux version.
 
Collision domains are composed of all the machines sharing any given transport medium.
There are some important protocols for you to pay attention to as an ethical hacker— mainly because of their simplicity. SMTP, FTP, TFTP, SNMP, POP3, and HTTP are all Application layer protocols with information readily available to captured traffic. Pro- tocols at the Transport and Network layers can also provide relevant data. TCP and UDP work in the Transport layer and provide the port numbers that both sides of a data exchange are using. TCP also adds sequence numbers, which will come into play later during session hijacking. IP is the protocol working at the Network layer, and there is a load of information you can glean just from the packets themselves.
Inside each individual network segment, the frame needs a physical address (the MAC) to deliver it to a specific system. The MAC address of an intended recipient is actually the address burned onto the NIC. The MAC address (a.k.a. physical address) that is burned onto a NIC is made of two sections. The first half of the address, 3 bytes (24 bits), is the organizational unique identifier and is used to identify the card manu- facturer. The second half is a unique number burned in at manufacturing to ensure no two cards on any given subnet will have the same address. When the frame is being built inside the sending machine, the system uses a protocol called Address Resolution Protocol (ARP) to find the corresponding MAC address for a given IP.
If the IP address of the packet being sent is not inside the same subnet, the route table on your host already knows the packet should be sent to the default gateway (lo- cal router port). If it doesn’t happen to remember the default gateway’s MAC address, it’ll send out a quick ARP request to pull it. Once the packet is properly configured and delivered to the default gateway, the router will open it, look in the route table, and build a new frame for the next subnet along the route path. As that frame is being built, it will send another ARP request for that segment.
ARP retains a cache on machines as it works. Use the ping, arp, and netsh commands on a Windows machine to see this in action. ARP also works on a broadcast basis.
IPv6 is the “next generation” of Internet Protocol addressing. It uses a 128-bit address instead of the 32-bit IPv4 version, and IT is represented as eight groups of four hexadecimal digits separated by colons (for example, 2002:0b58:8da3:0041:1000:4a 2e:0730:7443). Leading zeroes from any groups of hexadecimal digits can be removed, and consecutive sections of zeroes can be replaced with a double colon (::). This is usu- ally done to either all or none of the leading zeroes. For example, the group 0054 can be converted to 54. The design actually reduces router processing. The header takes up the first 320 bits and contains source and destination addresses, traffic classification options, hop count, and extension types. Referred to as “Next Header,” this extension field lets the recipient know how to interpret the data payload. In short, among other things, it points to the upper-layer protocol carried in the payload. The IPv6 “loopback” address is 0000:0000:0000:0000:0000:0000:0000:0001 and may be edited all the way down to ::1.

IPv6 address types include unicast, multicast, and anycast, and the scopes for mul- ticast and unicast include link local, site local, and global. The good old broadcast address in IPv4 (which was sent to all hosts in a network segment) is no longer used. Unicast is just like IPv4 (addressed for one recipient) and so is multicast (addressed 
for many). Anycast works just like multicast; however, while multicast is intended to be received by a bunch of machines in a group, anycast is designed to be received and opened only by the closest member of the group.
In IPv6, the address block fe80::/10 has been reserved for link-local addressing. The unique local address (the counterpart of IPv4 private addressing) is in the fc00:: /7 block. Prefixes for site-local addresses will always be “FEC0::/10.”
The scope for multicast or anycast defines how far the address can go. A link-local scope defines the boundary at the local segment, with only systems on your network segment getting the message. Site-local is much the same; however, it is defined via a site. A site in IPv6 addressing can be a fairly confusing subject since the same rules apply as the link-local scope (not forwarded by a router). For example, link local can be used for private networking and autoconfiguration of addressing like your out-of-the- box easy networking of the 169.254.0.0 network, and site local is more akin to setting up your private networks using predefined ranges.
EC-Council breaks sniffing down into two main categories: passive and active. Pas- sive sniffing is simply plugging in a sniffer and, without any other interaction needed on your part, starting to pull data packets to view at your leisure. Passive sniffing works only if your machine’s NIC is part of the same collision domain as the targets you want to listen to (hubs). Active sniffing requires some additional work on your part, either from a packet injection or manipulation stance or from forcing network devices to play nicely with your efforts. Active sniffing basically means the collision domain you are part of is segmented from those you want to look in to. Usually this means you’re attached to a switch.
Tricking the switch into closing your port every time it closes another one can be accomplished by configuring a span port, which is a scan in which the switch configu- ration has been altered to send a copy of all frames from one port, or a succession of ports, to another (also called port mirroring).
Another active sniffing technique, making the switch behave like a hub by closing all ports, is accomplished by overwhelming the content addressable memory (CAM) table. This method, which doesn’t work on a lot of modern switches but is questioned repeat- edly and often on your exam, is known as MAC flooding. The idea is simple: Send so many MAC addresses to the CAM table it can’t keep up, effectively turning it into a switch. MAC flooding works by sending tons of unsolicited MACs to the switch, filling up the CAM table. Because the CAM is finite in size, it fills up fairly quickly and entries begin rolling off the list. Etherflood and Macof are examples of tools you can use to try this.
Most modern switches protect against MAC floods but may still be susceptible to MAC spoofing. When a MAC address is spoofed, the switch winds up with multiple entries in the CAM table for a given MAC address. Unless port security is turned on, the latest entry in the table is the one that is used. MAC duplication is another term used in sniffing lingo. Sure, it involves spoofing a MAC address, but it’s more in the realm of a denial-of-service attack.

Port security refers to a security feature on switches that allows an administrator to manually assign MAC addresses to a specific port, or even a specific number of addresses a port is allowed to resolve. If the machine connecting to the port does not use that 
particular MAC, it isn’t allowed to connect, and if more than the number allowed attempt to use the same port, it will lock. Tools for spoofing a MAC address include Cain and Abel, Scapy (native to Unix), Packet Crafter, and SMAC.
ARP poisoning (a.k.a. gratuitous ARP) is the process of maliciously changing an ARP cache on a machine to inject faulty entries. Tools that make ARP flooding as easy as pressing a button are Cain and Abel (a great Windows hacking tool), WINARPAttacker, Ufasoft, and dsniff (a collection of Linux tools holding a tool called ARPspoof).
DHCP starvation is an attack whereby the malicious agent attempts to exhaust all available addresses from the server. While it’s more of a denial-of-service type of attack, don’t be surprised to see it pop up in a sniffing question. Configuring DHCP snooping on your network device is considered the proper mitigation against this attack.
Wireshark, Ettercap, EtherPeek, and even Snort (better known as an IDS, though) are all examples of sniffers.
Wireshark can capture packets from wired or wireless networks and provides a fairly easy-to-use interface. The top portion of the display is called the Packet List and shows all the captured packets. The middle portion, Packet Detail, displays the sections within the frame and packet headers. The bottom portion displays the actual hex entries in the highlighted section. Following a TCP stream is a great way to discover passwords in the clear. Another great feature of Wireshark is its ability to filter a packet capture to your specifications. A filter can be created by typing in the correct stream in the filter window, by right-clicking a packet or protocol header and choosing Apply As Filter, or by clicking the Expression button beside the filter screen and checking off what you’d like. In any case, the filter will display only what you’ve chosen.
Examples of filters include host 192.168.1.102 (displays traffic to or from 192.168.1.102), net 192.168.1.0/24 (displays traffic to or from the subnet 192.168.1.1- 255), and port 80 (displays all port 80 traffic). During a capture, you can also click the Capture Filters selection from the Capture menu item and choose all sorts of pre- defined filters. Wireshark also has the ability to filter based on a decimal numbering system assigned to TCP flags. The assigned flag decimal numbers are FIN = 1, SYN = 2, RST = 4, PSH = 8, ACK = 16, and URG = 32. Adding these numbers together (for example, SYN + ACK = 18) allows you to simplify a Wireshark filter. For example, tcp .flags == 0x2 looks for SYN packets, tcp.flags == 0x16 looks for ACK packets, and tcp .flags == 0x18 looks for both.
tcpdump is another popular sniffing tool (WinDump is a Windows GUI version). It is a command-line tool that simply prints a description of the contents of packets on a network interface that match a given filter (Boolean expression). The syntax for this tool is fairly simple: tcpdump flag(s) interface. For example, tcpdump -i eth1 puts the interface in listening mode, capturing pretty much anything that comes across eth1. If you were to add the -w flag, you could specify a file in which to save the data, for review later. The follow- ing command will show all data packets (no SYN, FIN, or ACK-only) to and from port 80:
tcpdump 'tcp port 80 and (((ip[2:2] - ((ip[0]&0xf)<<2)) -
((tcp[12]&0xf0)>>2)) != 0)'

Other tools include Ettercap (a powerful sniffer and man-in-the-middle suite of programs), Snort (most often discussed as an intrusion detection application), Ether- Peek, WinDump, and WinSniffer.
Intrusion detection systems (IDSs) are hardware and/or software devices that exam- ine streams of packets for unusual or malicious behavior. This is done via a signature list, where the IDS compares packets against a list of known traffic patterns that indicate an attack or via a traffic comparison over time, where the anomaly-based system learns the normal traffic patterns of the subnet. A signature-based system is only as good as the signature list itself; if you don’t keep it up to date, newer intrusion methods may go undetected. A behavior-based system may be better at picking up the latest attacks because they would definitely be out of the norm. An anomaly-based system is more susceptible to false positives. A false negative occurs when traffic is deemed to be fine, with no alarm sounding when, in fact, an intrusion attempt did occur.
IDSs are either host based (HIDS) or network based (NIDS). HIDSs reside on the host, providing individual host protection. NIDSs provide monitoring of all network traffic, based on where the network tap is installed. Some popular HIDS examples in- clude Cybersafe, Tripwire, Norton Internet Security, and even firewalls and other fea- tures built into the operating system.
Snort is an open source NIDS that combines the benefits of signature-, protocol-, and anomaly-based inspection. It has become the de facto standard for IDS and is in use on networks ranging from small businesses to U.S. government enterprise systems. It is a powerful sniffer, traffic logging, and protocol analyzing tool that can detect buf- fer overflows, port scans, operating system fingerprinting, and almost every conceivable external attack or probe you can imagine.
Snort rules are composed of an action, a protocol, a source address/port, a destina- tion address/port, and message parameters. Here’s an example:
alert tcp !HOME_NET any -> $HOME_NET 31337 (msg :"BACKDOOR ATTEMPT-Backorifice")
Raw Snort output provides all sorts of information, and the ports and addresses sections are of specific importance.
A firewall is an appliance within a network that is designed to protect internal resources from unauthorized external access. Firewalls work with a set of rules, explicitly stating what is allowed to pass from one side of the firewall to the other. Additionally, most firewalls work with an implicit deny principle. Firewalls can be discovered by traceroute, port-scanning tools, and a variety of other methods.
Firewalls are packet-filtering or stateful devices. Packet-filtering firewalls look at the headers of packets coming through a port and decide whether to allow them based on the ACLs configured. Stateful firewalls have the means to track the entire status of a connection.

ACK tunneling and HTTP tunneling are examples of firewall evasion techniques, although stateful firewalls can help prevent ACK tunneling. Firewalking is the process of examining each port on the firewall to discover potential attack vectors. The best method of firewall evasion is to use a compromised machine on the inside to initiate all communication.


Chapter 5
System attacks fall in the gaining access ethical hacking phase. The full methodology includes reconnaissance, scanning, gaining access, maintaining access, and clearing tracks. Gaining access and maintaining access can be broken down further into crack- ing passwords, escalating privileges, and executing applications. Hiding files and clear- ing logs are part of the covering tracks step. Before starting a system attack, ensure all footprinting, scanning, and enumeration efforts have been completed.
After you’ve cracked a password, according to the methodology, you move up to escalating privileges. After privilege escalation, you leave the gaining access phase and move into maintaining access. Here the objective is to set up some things to ensure you can come back to this target and play around later. The idea is to execute a few applica- tions that provide long-term access. The covering tracks phase is exactly what it sounds like: You’ve busted in, gotten control, and set up a way back in for later access, but now it’s time to clean up the mess so the owner doesn’t notice anything amiss. Cleaning up and wiping down simply means you take care of log files on the machine and do your best to hide or obscure the applications you leave behind.
Windows Security architecture questions include “Where are passwords stored on the system?” and “How does Windows authenticate users?” The passwords themselves aren’t stored anywhere on the machine. Microsoft Windows stores authentication cre- dentials in something called the Security Accounts Manager (SAM) file, located in the C:\windows\system32\config file. The hash value of passwords is stored in the SAM file, and a hash is a one-way mathematical algorithm that produces a unique output for a given input. Since it’s one way (in other words, you cannot simply reverse the hash
value to the input it came from), storing the hash—and sending the hash across the wire for authentication—is a pretty good idea.
Additional security (introduced in Windows NT 4.0) for the SAM file against offline software cracking can be found with the SYSKEY function. When SYSKEY is enabled, the SAM file is partially encrypted, requiring the addition of a key to decrypt should the file be stolen. SYSKEY uses a 128-bit RC4 key.
Windows 2000 and Windows NT–type machines use something called LAN Man- ager, and then NT LAN Manager, to hash passwords. LM hashing would first take the password and convert everything to uppercase. Then, if the password was less than 14 characters, it would add blank spaces to get it to 14. Then the new, all-uppercase, 14-character password would be split into two 7-character strings. These strings would be hashed separately, with both hashes then combined for the output. If a password is seven characters or less (or uses only one or two character spaces in the second por- tion), this significantly reduces the amount of time required to crack the rest of it be- cause the LM hash value of seven blank characters will always be the same (AAD3B- 435B51404EE). LM uses DES as a hash algorithm, with a 56-bit key. NTLM uses MD4 as a hash algorithm and outputs a 128-bit value. NTLMv2 uses MD5 for hashing and also outputs 128-bit values.
Kerberos makes use of both symmetric and asymmetric encryption technologies to securely transmit passwords and keys across a network. The entire process consists of a key distribution center (KDC), an authentication service (AS), a ticket granting service (TGS), and the ticket granting ticket (TGT). In a basic Kerberos exchange, the client first asks the KDC (which holds the AS and TGS) for a ticket, which will be used to authen- ticate throughout the network. This request is in clear text. The server will respond with a secret key, which is hashed by the password copy kept on the server (in Active Direc- tory). This is known as the TGT. If the client can decrypt the message (and it should since it knows the password), the TGT is sent back to the server requesting a TGS service ticket. The server responds with the service ticket, and the client is allowed to log on and access network resources.
The Windows registry is a collection of all the settings and configurations that make the system run. Hierarchical in nature, it stores settings for low-level operating system components, applications running on the machine, drivers, the SAM file, and the user interface. Two basic elements make up a registry setting: keys and values. A key can be thought of as a location pointer, much like a folder in the regular file structure, and the value of that key defines the setting. Keys are arranged in a hierarchy, with root keys at the top, leading downward to more specific settings. The root-level keys in the registry are HKEY_LOCAL_MACHINE (HKLM), HKEY_CLASSES_ROOT (HKCR), HKEY_CUR- RENT_USER (HKCU), HKEY_USERS (HKU), and HKEY_CURRENT_CONFIG (HKCC).

Values can be a character string (REG_SZ), an “expandable” string value (REG_EX- PAND_SZ), binary (REG_BINARY), or a host of other goodies. Remaining entries of note include the DWORD value (REG_DWORD—a 32-bit unsigned integer), the link value (REG_LINK—a symbolic link to another key), and the multisize value (REG_ MULTI_SZ—a multistring value). Some of the keys of great importance to you in particular (for your exam and your job) include
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce, HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunServices, HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce, and HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run.
Linux is a powerful OS that can be used for several purposes. The Linux file system starts with a root directory just as Windows does. The Windows root is usually C:\, and the Linux root is just a slash (/). Security on files and folders is managed through your user account, your user’s group membership, and three security options that can be as- signed to each for any resource: read, write, and execute. These permissions are assigned via the chmod command and the use of the binary equivalent for each rwx group: Read is equivalent to 4, write is 2, and execute is 1.
All users and groups are organized via a unique user ID (UID) and group ID (GUID). Information for both can be found within the /etc/passwd file. Passwords in Linux can be stored in the passwd file or in the shadow file, the latter of which encrypts the stored passwords. The passwords contained within are actually hashes that, usually, have a salt assigned. John the Ripper will run through brute-force hashing and tackle the salts.
You need three commands to compile any program in Linux: ./configure, make, and make install. Compiling raw programs to a recognizable form for the OS can be done using the GNU Compiler Collection (GCC). GCC can compile and execute from sever- al languages, such as C, C++, and Fortran. Linux kernel modules (LKMs) were invented early on to provide some modularity to the operating system. LKMs allow functionality without forcing the entire OS to be rewritten and reinstalled. The command to load an LKM is as follows:
modprobe LKM_name
Hardening a Linux machine includes physical location, file, and user account security steps. Nessus, Retina, Core Impact, and SAINT are all examples of vulnerability scanners to assist in pointing out potential problems with a Linux install.
Authentication to any system can rely on three things: something you are (biometrics, such as fingerprints), something you have (a token or card of some sort), and something you know (a password). A password’s strength is determined by two major functions: length and complexity. Password types are defined by what’s in them and can be made up of letters, numbers, special characters, or some combination of all three.
In general, passwords must not contain any part of the user’s name, must have a minimum of eight characters, and must contain characters from at least three of the four major components of complexity (special symbols, uppercase letters, lowercase letters, and numbers).

There are four types of password attacks. A passive online attack involves sniffing a wire in the hopes of intercepting a password in clear text or attempting a replay or man- in-the-middle attack. Sidejacking is another attack that’s similar and is used against encrypted passwords and SSL by stealing cookies exchanged between two systems and replaying them. Cain, Ettercap, ScoopLM, and KerbCrack (KerbSniff) are examples of tools that accomplish this.

193

An active online attack occurs when the attacker begins simply guessing passwords. Active online attacks take much longer than passive attacks and are also much easier to detect. These attacks try to take advantage of bad passwords and security practices by individuals on a network.
Offline attacks occur when the hacker steals a copy of the password file and works the cracking efforts on a separate system. These attacks usually require some form of physical access to the machine, where the attacker pulls the password file to removable media. Password cracking offline can be done in one of three major ways: dictionary attacks, hybrid attacks, and brute-force attacks.
A dictionary attack is the easiest and uses a list of passwords in a text file, which is then hashed by the same algorithm/process the original password was put through. This can also be sped up using rainbow tables. A hybrid attack is a step above the dictionary attack. In a hybrid attack, the cracking tool takes words from a list and substitutes numbers and symbols for alphabetic characters. Hybrid attacks may also append numbers and symbols to the ends of dictionary file passwords. Brute-force attacks attempt every con- ceivable combination of letters, numbers, and special characters, comparing them against the hash to determine a match. This process is very time-consuming, chewing up a lot of computation cycles and making this the longest of the three methods. Cain, KerbCrack, Legion, and John the Ripper are examples of brute-force password-cracking tools.
Keylogging is the process of using a hardware device or software application to cap- ture the keystrokes a user types. With this method, keystrokes are captured as they are typed, regardless of what they’re being typed for. Keyloggers can be hardware devices— usually small devices connected between the keyboard cable and the computer—or software applications installed and running in the background.
Nonelectronic attacks involve social engineering attempts, which can take on many different forms. This is perhaps the most effective and easiest method available. Produc- tive methods include shoulder surfing and phishing.
Escalation of privileges is the bridge between gaining access and maintaining access and usually falls into four main options for obtaining administrator (root) privileges on a machine. The first is to crack the password of an administrator or root account. The second is to take advantage of a vulnerability found in the OS, or in an application, that will allow you access as a privileged user. The third method is to use a tool that, ideally, provides you with the results you’re looking for. The last method involves more social engineering, such as putting executable code in an e-mail and asking the user to click it. This is the easiest method available and probably will wind up being your most effective over time.
There are two types of privilege escalation. Vertical privilege escalation occurs when a lower-level user executes code at a higher privilege level than they should have access to. Horizontal privilege escalation isn’t really escalation at all but rather simply executing code at the same user level but from a location that should be protected from access.

One really great way to hide files on Windows machines is through the use of an alternate data stream (ADS) in the form of New Technology File System (NTFS) file streaming. ADS is a feature of the Windows-native NTFS to ensure compatibility with Apple file systems (called HFS), not to mention the ability for loads of back-end 
eatures built into the OS and applications. NTFS file steaming allows you to hide virtu- ally any file behind any other file, rendering it invisible to directory searches. Protection against this includes LNS and Sfind, both created specifically to hunt down ADS. Win- dows Vista introduced a directory command (dir /r) that will display all file streams in the directory. Lastly, copying files to and from a FAT partition blows away any residual file streams in the directory.

Another file-hiding technique is steganography. Steganography hides files in plain sight, buried within an image of another file. Tools for hiding files of all sorts in regular image or other files are ImageHide, Snow, Mp3Stego, Blindside, S-tools, wbStego, and Stealth. Another term used in regard to steganography is semagram, and there are two types. A visual semagram uses an everyday object to convey a message. Examples can include doodling, or the way items are laid out on a desk. A text semagram obscures a message in text by using font, size, type, or spacing.


Chapter 6
The two major web server providers to know for CEH are Apache and Internet Infor- mation Services (IIS) servers. Apache is an open source, powerful, and fast web server that typically runs on a Unix or Linux platform, although you can load and use it on a wide variety of operating systems. Apache is built modularly, with a core to hold all the “magic” and modules to perform a wide variety of functions. Additionally, because of its open source nature, there is a huge library of publicly available add-ons to support all sorts of function and service. Apache configuration is almost always done as part of a module within special files (http.conf, for instance, can be used to set server status), and the modules are appropriately named (mod_negotiation, for instance).
IIS servers are easy-to-manage, Windows-based options for the web provider. Almost everything questioned on IIS configuration is going to come down to privileges, and IIS itself will spawn all shells as LOCAL_SYSTEM.
Whether it’s an Apache or an IIS server, misconfiguration of the settings is the most common vulnerability that will be exploited. Properly configuring (restricting?) remote administration, eliminating unnecessary services, changing any default passwords or accounts, and error reporting are settings of concern.

HTTP was designed to pull and display HTML files inside a browser. These HTML files consist of a bunch of tags that tell the browser how to display the data inside. This sim- plicity makes HTML easy to work with but also has its own issues. HTML entities were created as a way of telling the browser to display those characters it would otherwise look at as a tag or part of the programming itself. Examples include &nbsp;, &lt;, and &gt;.

HTTP request are pretty straightforward and easy to understand. The most common are HTTP HEAD, GET, and POST. An HTTP HEAD requests headers and metadata. It works exactly like an HTTP GET, except it doesn’t return any body information to display within your browser. An HTTP GET basically requests data from a resource. However, HTTP GET can be used to send data as well, and when sending data, the GET method adds the data to the URL.
A POST, on the other hand, is a much better method of submitting data to a resource for processing. It can also be used to elicit a response, but its primary purpose is to provide data for the server to work with. POST is generally considered safer than GET because it is not stored in browser history or in the server logs, and it doesn’t display returned data in the URL.
EC-Council defines six different stages in web server attack methodology: informa- tion gathering, footprinting, mirroring websites, vulnerability scanning, session hijack- ing, and password cracking. You probably won’t be tested on the order, but you should be aware of it.
A vulnerability scanner will practically give you everything you need to gain access. Nessus is probably the most common vulnerability scanner available, but it’s certainly not the only option. Nikto is a vulnerability scanner more suited specifically for web servers.
Directory traversal is one form of attack that’s common and successful. In this attack, the hacker attempts to access restricted directories and execute commands out- side intended web server directories. Also known as the dot-dot-slash attack, directory climbing, and backtracking, this attack basically sends HTTP requests asking the server to drop back to the root directory and give access to other folders. This dot-dot-slash attack is also known as a variant of Unicode or unvalidated input attack. Unicode is a standard for ensuring consistent encoding and text representation and can be accepted by servers for malicious purposes. Unvalidated input means the server has not been configured to accept only specific input during an HTTP GET, so an attacker can craft the request to ask for command prompts, to try administrative access passwords, and so on.
Another attack that sometimes involves a lot of trial and error is parameter tamper- ing (a.k.a. URL tampering). In this attack, the hacker simply manipulates parameters within the URL string in hopes of modifying data, such as permissions and elevation of privileges, prices and quantities of goods, and credentials.
Another version of parameter tampering (trust me) involves manipulating the hid- den field on the source. This involves copying the code to the local system, manipulating the hidden field, and then opening the page again to use the newly configured tag.
Web applications are most often hacked because of inherent weaknesses built into the program at inception. Developers might overlook known vulnerabilities, forget to patch security flaws, or leave default passwords and accounts open for exploitation. In analyzing a web application to attack, EC-Council identifies four key efforts: identify entry points, identify server-side function, identify server-side technologies, and map the attack surface.
Identifying entry points includes examining cookies, headers, POST data, and encoding or encryption measures. Also, don’t ignore the obvious—the URL can tell you a lot (input parameters and such are often displayed there). Several tools can help in identifying your entry points including WebScarab, HttPrint, and Burp Suite. Identifying

function and technology on the server side is really footprinting and fingerprinting combined. Mapping the attack surface is simply EC-Council’s way of saying you should know what information is best suited to set up a specific attack vector.
One successful web application attack deals with injecting malicious commands into the input string. The objective is much like that of the URL-tampering methods discussed earlier in this chapter: to pass exploit code to the server through poorly designed input validation in the application. This can occur using a variety of methods, including file injection (where the attacker injects a pointer in the web form input to an exploit hosted on a remote site), command injection (where the attacker injects commands into the form fields instead of the expected test entry), and shell injection (where the attacker attempts to gain shell access using Java or other functions).
A buffer overflow attack, also known as smashing the stack, is an attempt to write more data into an application’s prebuilt buffer area in order to overwrite adjacent memory, execute code, or crash a system (application). The buffer overflow attack categories are stack, heap, and NOP sled.
Sometimes developers use canaries or canary words in buffer overflow detection. In buffer overflow and programming parlance, canary words are known values placed between the buffer and control data. If a buffer overflow occurs, the canary word will be altered first, triggering a halt to the system. Tools such as StackGuard use this for stack protection.
Cross-site scripting (XSS) is an attack revolving around website design and dynam- ic content. Usually when a web form pops up, the user inputs something, and then some script dynamically changes the appearance or behavior of the website based on what has been entered. XSS occurs when the bad guys take advantage of that scripting (Java, for instance) and have it perform something other than the intended response. A URL such as the following is an indicator of an XSS attempt: http://IPADDRESS/";!- -"<XSS>=&{()}.
A cookie is a small, text-based file that is stored on your system for use by the web server the next time you log in. It can contain all sorts of information, including authentication details, site preferences, shopping cart contents, and session details. Cookies are sent in the header of an HTTP response from a web server and may or may not have an expiration date. Passwords can sometimes also be stored in cookies, and although it’s a horrible practice, it’s still fairly prevalent.
LDAP injection is an attack that exploits nonvalidated web input that passes LDAP queries. In other words, if a web application takes whatever is entered into the form field and passes it directly as an LDAP query, an attacker can inject code to do all sorts of stuff. SOAP injection is another related attack. Simple Object Access Protocol (SOAP) is designed to exchange structured information in web services in computer networks and uses XML to format information.

SQL injection is, by far, the most common and most successful injection attack technique in the world. Structured Query Language (SQL) is a computer “language” designed for managing data in a relational database system. The relational database is simply a collection of tables (consisting of rows, which hold individual fields con- taining data) tied together using some common field (key) that you can update and query. Each table has a name given to it that is referenced when you perform queries or updates. SQL comes into play when you are adding, deleting, moving, updating, or viewing the data in those tables and fields.
SQL queries generally begin with the SELECT command. SELECT is used to choose the data you’d like to perform an action on. In addition to SELECT, there are several additional options and commands of great interest to a hacker. For example, DROP TABLE tablename will delete the table tablename from the database. INSERT and UPDATE are also easy to understand.
SQL injection occurs when the attacker injects SQL queries directly into the input form. Properly constructed, the SQL command bypasses the intent of the front end and executes directly on the SQL database. To find out whether a site is susceptible to SQL injection, check your target for a web login page, and instead of entering what’s asked for on the web form, simply try a single quote (') and see what kind of error message, if any, you receive. If that doesn’t work, try entering anything' or 1=1- and see what you get. The attack names and definitions for SQL are union query, tautology, blind SQL injection, and error-based SQL injection.

sqlmap, Havij, and sqlninja are all automated scanners designed to look specifically for injection vulnerabilities. SQLBrute is a tool that allows you to blast through pre- defined SQL injection queries against a target. Others include, but are not limited to, Pangolin, SQLExec, Absinthe, and BobCat.
 

Chapter 7
A wireless network is built with the same concerns as any other media you decide to use. In the wireless data world, these are all defined with standards, known as the 802.11 series. 802.11a can attain speeds up to 54Mbps and uses the 5GHz range. 802.11b has speeds of 11Mbps at 2.4GHz, and 802.11g is 54Mbps at 2.4GHz. 802.11n has speeds over 100Mbps and uses a variety of ranges in MIMO format between 2.4GHz and 5GHz.
Two other standards of note are 802.11i and 802.16. 802.11i is an amendment to the original 802.11 series standard and specifies security mechanisms for use on the WLAN (wireless LAN). 802.16 was written for the global development of broadband wireless metropolitan area networks. Referred to as “WiMax,” it provides speeds up to 40Mbps and is moving toward gigabit speed.
Modulation—the practice of manipulating properties of a waveform—is the encoding method of choice in wireless networks. OFDM and DSSS are the modulation methods of choice. Both orthogonal frequency-division multiplexing (OFDM) and direct-sequence spread spectrum (DSSS) use various pieces of a waveform to carry a signal. OFDM works with several waveforms simultaneously carrying messages back and forth: The transmission media is divided into a series of frequency bands that don’t overlap each other, and each of them can then be used to carry a separate signal. DSSS works differently by combining all the available waveforms into a single purpose; the entire frequency bandwidth can be used at once for the delivery of a message.
There are two main modes a wireless network can operate in. The first is ad hoc, where your system connects directly to another system, as if a cable were strung be- tween the two. Infrastructure mode uses an access point (AP) to funnel all wireless con- nections through. A wireless access point is set up to connect with a link to the outside world (usually some kind of broadband router), and clients associate and authenticate to it. Clients connect to the access point using wireless NICs; if the access point is within range and the device understands what it takes to connect, it is allowed access to the network. Wireless networks can consist of a single access point or multiple ones, thus creating overlapping cells and allowing a user to roam freely without losing con- nectivity. The client needs to associate with an access point first and then disassociate when it moves to the next one.

When there is a single access point, its footprint is called a basic service area (BSA). Communication between this single AP and its clients is known as a basic service set (BSS). If you extend the range of your network by adding multiple access points, the setup is known as an extended service set (ESS). As a client moves from one AP in your 
subnet to another, so long as everything is configured correctly, it’ll disassociate from one AP and (re)associate with another seamlessly. This movement across multiple APs within a single ESS is known as roaming.
Wireless network design needs to take into account not only the type of antenna used but where it is placed and what is set up to contain or corral the signal. Physical installation of access points is a major concern because you will want to avoid spillage of the signal and loss of power. Most standard APs use an omnidirectional antenna, which means the signal emanates from the antenna in equal strength 360 degrees from the source.
Directional antennas allow you to focus the signal in a specific direction, which greatly increases signal strength and distance. Other antennas you can use are dipole and parabolic grid. Dipole antennas have, quite obviously, two signal “towers” and work omnidirectionally. Parabolic grid antennas work a lot like satellite dishes and can have phenomenal range (up to 10 miles) but aren’t in use much.
To identify a wireless network to clients who may be interested in joining, a service set identifier (SSID) must be assigned. The SSID is not a password and provides no security at all for your network. It is a text word (32 characters or less) that only distin- guishes your wireless network from others. SSIDs are broadcast by default and are easily obtainable even if you try to turn off the broadcast (in an effort dubbed SSID cloaking). The SSID is part of the header on every packet, so its discovery by a determined attacker is a given, and securing it is virtually a moot point.
Wireless authentication can happen in more than a few ways, from the simplistic to the complicated. A client can simply send an 802.11 authentication frame with the appropriate SSID to an AP and have it answer with a verification frame. Or, the client might participate in a challenge/request scenario, with the AP verifying a decrypted “key” for authentication. Or, in yet another twist, you may even tie the whole thing together with an authentication server (Radius), forcing the client into an even more complicated authentication scenario. The key here is to remember there is a difference between association and authentication. Association is the action of a client connect- ing to an AP, whereas authentication actually identifies the client before it can access anything on the network.
WEP stands for Wired Equivalent Privacy and provides weak security for the wireless network. Using 40-bit to 232-bit keys in an RC4 encryption algorithm, WEP’s primary weakness lies in its reuse of initialization vectors (IVs)—an attacker can simply collect enough packets to decode the WEP shared key. WEP was never intended to fully protect your data; it was designed to give people using a wireless network the same level of protection someone surfing over an Ethernet wired hub would expect.

WEP’s initialization vectors are relatively small and, for the most part, get reused pretty frequently. Additionally, they’re sent in clear text as part of the header. An attacker simply needs to generate enough packets in order to analyze the IVs and come up with the key used. This allows the attacker to decrypt the WEP shared key on the fly, in real time, and renders the encryption useless. Attackers can get APs to generate packets by sending disassociate messages. These aren’t authenticated by any means, 
so the resulting barrage of “Please associate with me” packets is more than enough for the attack.
A better choice in encryption technology is Wi-Fi Protected Access (WPA) or WPA-2. WPA makes use of Temporal Key Integrity Protocol (TKIP), a 128-bit key, and the client’s MAC address to accomplish much stronger encryption. The short of it is, WPA changes the key out (hence the “temporal” part of the name) every 10,000 packets or so, instead of sticking with one and reusing it. Additionally, the keys are transferred back and forth during an Extensible Authentication Protocol (EAP) authentication session, which makes use of a four-step handshake process in proving the client belongs to the AP, and vice versa.
WPA-2 is much the same process; however, it was designed with the government and the enterprise in mind. You can tie EAP or a Radius server into the authentication side of WPA-2, allowing you to make use of Kerberos tickets and all sorts of additional goodies. Additionally, WPA-2 uses AES for encryption, ensuring FIPS 140-2 compliance.
An AirPcap dongle is a USB wireless adapter that offers all sorts of advantages and software support. If you don’t have one, you may need to research and download new and different drivers for your particular card. The madwifi project may be an answer. Just keep in mind that, much like the ability of our wired adapters to use promiscuous mode for our sniffing efforts (discussed earlier in this book), not all wireless adapters are created equal, and not all will work with your favorite tool. Be sure to check the user guides and man pages for lists and tips on correctly configuring your adapters for use.
WIGLE (http://wigle.net) helps in identifying geographic locations of wireless net- works; teams of hackers have mapped out wireless network locations using GPS and a tool called NetStumbler. NetStumbler (www.netstumbler.com) can be used for identi- fying poor coverage locations within an ESS, detecting interference causes, and finding any rogue access points in the network. It’s Windows-based, easy to use, and compat- ible with 802.11a, b, and g.
Kismet is another wireless discovery option. It works on Linux-based systems and, unlike NetStumbler, works passively, meaning it detects access points and clients with- out actually sending any packets. It can detect access points that have not been config- ured (and would then be susceptible to the default out-of-the-box admin password) and will determine which type of encryption you might be up against. It works by “channel hopping” to discover as many networks as possible and has the ability to sniff packets and save them to a log file, readable by Wireshark or tcpdump.
Another great network discovery tool is NetSurveyor. This free, Windows-based tool provides many of the same features as NetStumbler and Kismet. Additionally, it sup- ports almost all wireless adapters without any significant additional configuration— which is of great benefit to hackers who can’t afford, or don’t have, an AirPcap card. NetSurveyor acts as a great tool for troubleshooting and verifying optimal installation of wireless networks.

Wireless sniffing is the next important step in hacking wireless networks. Much about sniffing a wireless network is exactly the same as sniffing its wired counterpart. The same protocols and authentication standard weaknesses you looked for with Wire- shark off that switch port are just as weak and vulnerable on wireless. Authentication 
information, passwords, and all sorts of information can be gleaned just from watching the air.
Just a few of the tools specifically made for wireless sniffing—in addition to Net- Stumbler and Kismet—include OmniPeek, AirMagnet WiFi Analyzer Pro, and WiFi Pilot. Assuming you have a wireless adapter that is compatible and can watch things in promiscuous mode, OmniPeek is a fairly well-known and respected wireless sniffer. In addition to the same type of traffic analysis you would see in Wireshark, OmniPeek provides network activity status and monitoring in a nice dashboard for up-to-the- minute viewing. AirMagnet WiFi Analyzer, from Fluke Networks, is an incredibly pow- erful sniffer, traffic analyzer, and all-around wireless network auditing software suite. It can be used to resolve performance problems and automatically detect security threats and vulnerabilities.
The rogue access point is an easy attack on a wireless network whereby an attacker sets up an access point near legitimate APs and tricks users into associating and authen- ticating with it. Sometimes referred to as an “evil twin,” an attack like this is easy to attempt. The only drawback is this attack is sometimes really easy to see, and you run a pretty substantial risk of discovery. You’ll just have to watch out for true security- minded professionals because they’ll be on the lookout for rogue APs on a continual basis and (should) have plenty of tools available to help them out.
An ad hoc connection attack takes advantage of the ad hoc mode of wireless net- working. An ad hoc connection attack occurs when an attacker simply sits down with a laptop somewhere in your building and advertises an ad hoc network from his laptop, and people eventually begin connecting to it.
Denial-of-service efforts are also easy attacks to attempt. This can be done in a couple ways, neither of which is particularly difficult. First, you can use any number of tools to craft and send de-authenticate (disassociate) packets to clients of an AP, which will force them to drop their connections. Granted, they may try to immediately climb back aboard, but there’s nothing stopping you from performing the same action again. The other easy DoS wireless attack is to jam the wireless signal altogether, using some type of jamming device and, usually, a high-gain antenna/amplifier. All wireless devices are susceptible to some form of jamming and/or interference—it’s simply a matter of placing enough signal out in the airwaves that the NICs can’t keep up. Tons of jammer options are available (a quick Google search on wireless jammers will show you around 450,000 pages on the subject), ranging from 802.11 networks to Bluetooth and other wireless networking technologies.
One defense wireless network administrators attempt to use is to enforce a MAC filter. Basically it’s a list of MAC addresses that are allowed to associate to the AP; if your wireless NIC’s address isn’t on the list, you’re denied access. The easy way around this is to monitor the network to figure out which MAC addresses are in use on the AP and simply spoof one of them.

Cracking WEP is ridiculously easy and can be done with any number of tools. The idea revolves around generating enough packets to effectively guess the encryption key. The weak initialization vectors we discussed already are the key; that is, they’re reused 
and sent in clear text. Regardless of the tool, the standard WEP attack follows the same basic series of steps.
Start a compatible wireless adapter on your attack machine and ensure it can both inject and sniff packets.
Start a sniffer to capture packets.
Use some method to force the creation of thousands and thousands of packets
(generally by using “de-auth” packets).
Analyze these captured packets (either in real time or on the side) with a cracking tool.
Tools for cracking WEP include Cain and Abel and Aircrack (both use Korek, but Aircrack is faster) as well as KisMac, WEPCrack, chopchop, and Elcomsoft’s Wireless Security Auditor tool. KisMAC runs on Mac OS X and can be used to brute-force WEP or WPA.
Mobile platform attacks come from a variety of attack vectors. BYOD is a ubiquitous business policy called Bring Your Own Device, allowing workers to bring and use their own personal mobile devices in the office. These devices have many vulnerable attack points, such as the apps themselves, malware, loss and theft, and unprotected WiFi access and sniffing. Rooting an Android device (gaining administrative control) is fairly simple with tools like SuperOneClick and Superboot. Sniffing or session hijacking can be just as easy with DroidSheep and FaceNiff.
Bluetooth refers to an open wireless technology for data exchange over relatively short range (10 meters or less). It was designed originally as a means to reduce cabling but has become a veritable necessity for cell phones and other mobile devices. Although hundreds of tools and options are available for Bluetooth hacking, the good news is their coverage on the exam is fairly light, and most of it comes in the form of identifying terms and definitions.
Bluetooth devices have two modes—a discovery mode and a pairing mode. Discovery mode determines how the device reacts to inquiries from other devices looking to connect and has three actions. The discoverable action obviously has the device answer to all inquiries, limited discoverable restricts that action, and nondiscoverable tells the device to ignore all inquiries.
Pairing mode details how the device will react when another Bluetooth system asks to pair with it. There are basically only two versions: Yes, I will pair with you, or no, I will not. Nonpairable rejects every connection request, whereas pairable accepts all of them.
Bluetooth attacks, taking advantage of this ease of use, fall into four general cat- egories. Bluesmacking is simply a denial-of-service attack against a device. Bluejacking consists of sending unsolicited messages to, and from, mobile devices. Bluesniffing is exactly what it sounds like, and, finally, Bluescarfing is the actual theft of data from a mobile device.

Some of the more common Bluetooth tools available for hacking include BlueScan- ner (from SourceForge), BT Browser, Bluesniff, and btCrawler. After identifying nearby 
devices, Super Bluetooth Hack is an all-in-one software package that allows you to do almost anything you want to a device you’re lucky enough to connect to. Other attack options include bluebugger and Bluediving (a full penetration suite for Bluetooth).

Chapter 8
Malware is generally defined as software designed to harm or secretly access a computer system without the owner’s informed consent. Software is considered to be malware based on the perceived intent of the creator rather than any particular features. Malware can also be defined as a “computer contaminant.”
Trojans are installed by sending the target an innocent-looking file, inviting him to open it. Once opened, it installs the Trojan, which is designed to steal specific types of information to send back, act as a keylogger, or perform other tasks, including providing a backdoor to the system for future access. Overt channels are legitimate communication channels used by programs across a system or a network, whereas covert channels are used to transport data in unintended ways. Most malware Trojans are downloaded from the Internet, moved via an IRC channel, or clicked as an attachment in an e-mail.
To make a Trojan appear as a legitimate application, the use of a wrapper is required. Wrappers are programs that allow you to bind an executable of your choice (Trojan) to an innocent file your target won’t mind opening. For example, you might use a program like EliteWrap to embed a backdoor application with a game file (.exe).

In CEH parlance, Trojans are categorized into different groups, each fairly easy to understand. These categories include Defacement, Proxy, FTP, VNC, and command shell. A command-shell Trojan is intended to provide a backdoor to the system that you connect to via command-line access. An example of this is Netcat. Known as the Swiss Army knife of TCP/IP hacking, Netcat provides all sorts of control over a remote shell on a target. When installed and executed on a remote machine, it opens a listening port of your choice. Entering the command nc –l –p 5555 opens port 5555 in a listening state on the target machine. You can then type nc IPAddress –p 5555 and connect to the target machine with a raw “telnet-like” connection. Netcat can be used for outbound or inbound connections, over TCP or UDP, to or from any port on the machine. It offers DNS forwarding, port mapping and forwarding, and proxying. You can even use it as a port scanner.

Some of the more common port numbers used by various Trojans are found in the following table (you’ll need to memorize them for your exam):

Several programs are available to you to keep an eye on the port numbers you have in use on your system. A Windows system command-line option is netstat. Entering the command netstat –an will show all connections and listening ports in numerical form. There are also port-scanning tools to make this easier for you. What’s Running, Fport, TCPView, and IceSword are all examples.
Prevention also requires keeping an eye on the registry, drivers and services being used, and your startup routines. Options include, but are not limited to, SysAnalyzer, Tiny Watcher, Active Registry Monitor, and RegShot. Additionally, many antivirus and malware scanners will watch out for registry errors. Malwarebytes will display all questionable registry settings it finds on a scan, for example. As an aside, Windows will automatically run everything located in Run, RunServices, RunOnce, and RunSer- vicesOnce, and you’ll find that most questions on your exam are centered around or show you settings from HKEY_LOCAL_MACHINE.
Services and processes are all big indicators of Trojan activity on a machine. Task Manager is a built-in option; however, processes and services can be monitored using many different tools. Windows Service Manager, Service Manager Plus, and Smart Utility are a few examples. And don’t forget to check the startup routines, where most of these will be present; it won’t do you much good to identify a bad service or process and then kill it, only to have it pop up again at the next startup.

Tripwire and SIGVERIF are used to verify the integrity of critical files, which is considered one of those bedrock actions you need to take in protecting against/detecting Trojans. Tripwire is a very well-respected integrity verifier that can act as a HIDS in pro- tection against Trojans, providing a warning when critical files are altered. SIGVERIF is built into Windows machines to help verify the integrity of critical files on the system. 

A virus is a self-replicating program that reproduces its code by attaching copies into other executable codes. In other words, viruses create copies of themselves in other programs. A few of the virus types and the definitions that go with them include the following:
Boot sector virus Also known as a system virus, this virus type moves the boot sector to another location on the hard drive, forcing the virus code to be executed first. They’re almost impossible to get rid of once you get infected. You can re-create the boot record—old-school fdisk or mbr could do the trick for you—but it’s not necessarily a walk in the park.
Shell virus Working just like the boot sector virus, this virus type wraps itself around an application’s code, inserting its own code before the application’s. Every time the application is run, the virus code is run first.
Multipartite virus This attempts to infect both files and the boot sector at the same time. This generally refers to a virus with multiple infection vectors. This link describes one such DoS-type virus: www.f-secure.com/v-descs/neuroqui. shtml. It is multipartite, polymorphic, retroviral, boot sector, and generally a pretty wild bit of code.
Macro virus Usually written with Visual Basic for Applications (VBA), this virus type infects template files created by Microsoft Office, normally Word and Excel. The Melissa virus was a prime example of this.
Polymorphic code virus This virus mutates its code using a built-in polymorphic engine. These viruses are difficult to find and remove because their signatures constantly change.
Metamorphic virus This virus type rewrites itself every time it infects a new file.
Stealth virus Also known as a “tunneling virus,” this one attempts to evade antivirus (AV) applications by intercepting the AV's requests to operating system (OS) and returning them to the virus instead of OS. The virus then alters the request and sends it back to AV as uninfected, making the virus now appear “clean.”
A worm is a self-replicating malware computer program that uses a computer network to send copies of itself to other systems without human intervention. Usually it doesn’t alter files, but it resides in active memory and duplicates itself, eating up resources and wreaking havoc along the way. The most common use for a worm in the hacking world is the creation of botnets.
The most common example of a worm is the Conficker worm, which disables services, denies access to administrator shared drives, locks users out of directories, and restricts access to security-related sites. Symptoms include an “Open folder to view files—Publisher not specified” message in the AutoPlay dialog box. (The original, and legitimate, Windows option reads “Open folder to view files using Windows Explorer.”) Conficker spreads as soon as it is opened (by clicking the first option) to open shares,
unpatched systems on the network, and systems with weak passwords. Systems with up-to-date patches and even decent passwords are usually safe.
To protect against viruses and Trojans, a good antivirus program is a must, and you can find good ones that are free or you can pay for one from one of the more well- known providers. The key to an effective AV application is keeping it up to date. Your system is only as good as your signature files. Another good option is the sheepdip computer. A sheepdip system is set up to check physical media, device drivers, and other files for malware before they are introduced to the network. Typically, this computer is used for nothing else and is isolated from the other computers, meaning it is not connected to the network at all. Sheepdip computers are usually configured with a couple of different AV programs, port monitors, registry monitors, and file integrity verifiers.
A denial-of-service attack is generally thought of as a last-resort attack and is designed to prevent legitimate users from accessing resources. The standard DoS attack seeks to accomplish nothing more than taking down a system or simply denying access to it by authorized users. The distributed denial-of-service (DDoS) attack comes not from one system but many.
A botnet is a network of zombie computers the hacker can use to start a distributed attack from (examples of botnet software/Trojans are Shark and Poison Ivy). These systems can sit idly by, doing other work for months before being called into action. That action may be as simple as sending a ping or performing some other task relevant to the attack at hand. Normally the preferred communications channel used to signal the bots is IRC or ICQ. Another DoS term is phlashing, which refers to a DoS attack that causes permanent damage to a system—usually damage to the hardware itself.
Here’s a sampling of DoS and DDoS attacks:
• SYN attack The hacker will send thousands upon thousands of SYN packets to the machine with a false source IP address. The machine will attempt to respond with a SYN/ACK but will be unsuccessful (because the address is false). Eventually, all the machine’s resources are engaged, and it becomes a giant paperweight.
• SYN flood In this attack, the hacker sends thousands of SYN packets to the target but never responds to any of the return SYN/ACK packets. Because there is a certain amount of time the target must wait to receive an answer to the SYN/ACK, it will eventually bog down and run out of available connections.
• ICMP flood Here, the attacker sends ICMP Echo packets to the target with a spoofed (fake) source address. The target continues to respond to an address that doesn’t exist and eventually reaches a limit of packets per second sent.
• Application level A simple attack whereby the hacker simply sends more “legitimate” traffic to a web application than it can handle, causing the system to crash.
Smurf The attacker sends a large number of pings to the broadcast address of the subnet, with the source IP spoofed to that of the target. The entire subnet will then begin sending ping responses to the target, exhausting the resources there. A fraggle attack is similar but uses UDP for the same purpose.
Ping of death (This isn’t a valid attack with modern systems but is still a definition you may need.) In the ping of death, an attacker fragments an ICMP message to send to a target. When the fragments are reassembled, the resultant ICMP packet is larger than the maximum size and crashes the system.
Teardrop In a teardrop attack, a large number of garbled IP fragments with overlapping, oversized payloads are sent to the target machine. On older operating systems (such as Windows 3.1x, Windows 95, and Windows NT operating systems), this takes advantage of weaknesses in the fragment reassembly functionality of their TCP/IP stack, causing the system to crash or reboot.
Also, more than a few tools are dedicated to performing DoS on systems. Low Orbit Ion Cannon (LOIC) is a simple-to-use DDoS tool that floods a target with TCP, UDP, or HTTP requests. Others include Trinity, Tribe Flood Network, and R-U-Dead-Yet.
Countermeasures against DoS attacks include disabling unnecessary services, using a good firewall policy, and keeping security patches and upgrades up to date. All these are pretty standard fare. Additionally, the use of a good NIDS can help against attacks from across the network. Strong, security-conscious code should be an absolute for your applications, and the use of tools such as Skydance can help detect and prevent DoS attacks. You might also look into network ingress filtering as well as some network auditing tools to help along the way.
Unlike DoS attacks, session hijacking attempts aren’t trying to break anything or shut off access. A session hijack takes advantage of a connection that is already active and authenticated. This differs a little from spoofing in that spoofing is pretending to be a different address with the intent of sniffing traffic while the client works. Hijacking refers to the active attempt to steal the entire session from the client: The server isn’t even aware of what happened, and the client simply connects again in a different session. Session hijack steps include the following:
1. Sniff the traffic between the client and the server.
2. Monitor the traffic and predict the sequence numbering. 3. Desynchronize the session with the client.
4. Predict the session token and take over the session.
5. Inject packets to the target server.
TCP session hijacking is possible because of the way TCP works. As a session-oriented protocol, it provides unique numbers to each packet, which allows the receiving machine to reassemble them in the correct, original order, even if they are received out of order.  Sequence numbers increment on acknowledgment and are an absolute must in stealing the session token.

A multitude of tools are available to assist in session hijacking. Ettercap is an excellent man-in-the-middle tool and can be run from a variety of platforms (although it is Linux native). Hunt and T-sight are probably the two best-known session-hijacking tools. Hunt can sniff, hijack, and reset connections at will, whereas T-sight (commercially available) can easily hijack sessions as well as monitor additional network connections. Other tools include, but are not limited to, Paros (more known as a proxy), BurpSuite, Juggernaut (a well-known Linux-based tool), Hamster, and Ferret.
A man-in-the-browser attack occurs when the hacker sends a Trojan to intercept browser calls. The Trojan basically sits between the browser and libraries, allowing a hacker to watch, and interact within, a browser session.
Countermeasures for session hijacking are using unpredictable session IDs, using encryption to protect the channel, limiting incoming connections, minimizing remote access, and regenerating the session key after authentication is complete. Additionally, user education is a valuable mitigation.

Chapter 9
Cryptography is the science or study of protecting information, whether in transit or at rest, by using techniques to render the information unusable to anyone who does not possess the means to decrypt it. Plain-text data (something you can read) is turned into cipher-text data (something you can’t read) by the application of some form of encryption. Encrypting data provides confidentiality because only those with the “key” can see it. Integrity can also be provided by hashing algorithms. Nonrepudiation is the means by which a recipient can ensure the identity of the sender and that neither party can deny having sent or received the message.

Encryption algorithms—mathematical formulas used to encrypt and decrypt data— are highly specialized and complex. There are two methods in which the algorithms actually work, and there are two methods by which these keys can be used and shared. In stream ciphers, bits of data are encrypted as a continuous stream. In other words, 
readable bits in their regular pattern are fed into the cipher and are encrypted one at a time. These work at a high rate of speed. Block ciphers combine data bits into blocks and feed them into the cipher. Each block of data, usually 64 bits at a time, is then encrypted with the key and algorithm. These ciphers are considered simpler, and slower, than stream ciphers.
Symmetric encryption, also known as single key or shared key, simply means one key is used both to encrypt and to decrypt the data. It is considered fast and strong but poses some significant weaknesses. It’s a great choice for bulk encryption because of its speed, but key distribution is an issue because the delivery of the key for the secured channel must be done offline. Additionally, scalability is a concern because as the net- work gets larger, the number of keys that must be generated goes up exponentially. DES, 3DES, Advanced Encryption Standard (AES), International Data Encryption Algorithm (IDEA), Twofish, and Rivest Cipher (RC) are examples.
Asymmetric encryption comes down to this: What the one key encrypts, the other key decrypts. It’s important to remember the public key is the one used for encryption, whereas the private key is used for decryption. Either can be used for encryption or decryp- tion within the pair, but in general remember public = encrypt, private = decrypt. Asym- metric encryption can provide both confidentiality and nonrepudiation and solves the problems of key distribution and scalability. The weaknesses include its performance (asymmetric is slower than symmetric, especially on bulk encryption) and processing power (asymmetric usually requires a much longer key length, so it’s suitable for smaller amounts of data). Diffie-Hellman, Elliptic Curve Cryptosystem (ECC), El Gamal, and RSA are examples.
A hashing algorithm is a one-way mathematical function that takes an input and produces a single number (integer) based on the arrangement of the data bits in the input. It provides a means to verify the integrity of a piece of data—change a single bit in the arrangement of the original data, and you’ll get a different response. The attack or effort used against hashing algorithm is known as a collision or a collision attack. A collision occurs when two or more files create the same output, which is not supposed to happen. To protect against collision attacks and the use of rainbow tables, you can also use a salt, which is a collection of random bits used as a key in addition to the hashing algorithm. MD5, SHA-1, and SHA2 are examples of hash algorithms.
Steganography is the practice of concealing a message inside another medium (such as another file or an image) in such a way that only the sender and recipient even know of its existence, let alone the manner in which to decipher it.
PKI is a structure designed to verify and authenticate the identity of individuals within the enterprise taking part in a data exchange. It can consist of hardware, software, and policies that create, manage, store, distribute, and revoke keys and digital certificates. The system starts at the top, with a (usually) neutral party known as the certificate authority (CA) that creates and issues digital certificates. The CA also keeps track of all the certificates within the system and maintains a certificate revocation list (CRL), used to track which certificates have problems and which have been revoked.

A digital certificate is an electronic file that is used to verify a user’s identity, providing nonrepudiation throughout the system. The certificate typically follows the X.509 standard, which defines what should and should not be in a digital certificate. 
Version, Serial Number, Subject, Algorithm ID (or Signature Algorithm), Issuer, Valid From and Valid To, Key Usage, Subject’s Public Key, and Optional are all fields within a digital certificate. A digital signature is nothing more than an algorithmic output that is designed to ensure the authenticity (and integrity) of the sender.

Cipher attacks fall into a few categories and types. Known plain-text attacks, cipher- text-only attacks, and replay attacks are examples. A man-in-the-middle situation is usually listed as a type of attack by many security professionals and study guides (depending on the test version you get, it may even be listed as such). Just keep in mind that a man-in-the-middle situation simply means the attacker has positioned himself between the two communicating entities. Brute force refers to an attempt to try every possible combination against a target until successful.


Chapter 10
Social engineering is the art of manipulating a person, or a group of people, into pro- viding information or a service they otherwise would never have given. Social engineers prey on people’s natural desire to help one another, to listen to authority, and to trust offices and entities. Social engineering is a nontechnical method of attacking systems.
All social-engineering attacks fall into one of two categories: human-based or computer-based. Human-based social engineering uses interaction in conversation or other circumstances between people to gather useful information.
Dumpster diving is an attack where the hacker digs through the trash for useful information. Rifling through dumpsters, paper-recycling bins, and office trashcans can provide a wealth of information, such as passwords (written down to make them “easier to remember”), network design documents, employee phone lists, and other information.

Impersonation is an attack where a social engineer pretends to be an employee, a valid user, or even an executive (or other VIP). Whether by faking an identification card 
or simply convincing the employees of his “position” in the company, an attacker can gain physical access to restricted areas, providing further opportunities for attacks. Pre- tending to be a person of authority, the attacker might also use intimidation on lower- level employees, convincing them to assist in gaining access to a system.
A technical support attack is a form of impersonation aimed at the technical support staff themselves. An attacker can call up posing as a user and request a password reset. The help desk person, believing they’re helping a stranded customer, unwittingly resets a password to something the attacker knows, thus granting him access the easy way.
Shoulder surfing is a basic attack whereby the hacker simply looks over the shoulder of an authorized user. If you have physical access, you can watch users log in, access sensitive data, or provide valuable steps in authentication.
Tailgating and piggybacking are two closely related attacks on physical security. Tail- gating occurs when an attacker has a fake badge and simply follows an authorized person through the opened security door—smokers’ docks are great for this. Piggyback- ing is a little different in that the attacker doesn’t have a badge but asks for someone to let him in anyway. Attackers may say they’ve left their badge on the desk or forgot it at home. In either case, an authorized user holds the door open for them despite the fact they have no badge visible.
In reverse social engineering, the attacker will pose as someone in a position of some form of authority or technical support and then set up a scenario whereby the user feels they must dial in for support. Specific steps are taken in this attack—advertise- ment, sabotage, and support. First, the attacker will advertise or market their position as “technical support” of some kind. Second, the attacker will perform some sort of sabotage, whether a sophisticated DoS attack or simply pulling cables. In any case, the damage is such that the user feels they need to call technical support, which leads to the third step, where the attacker attempts to “help” by asking for login credentials and thus gains access to the system.
Computer-based attacks are those attacks carried out with the use of a computer or other data-processing device. The most common method of computer-based social engineering is known as phishing. A phishing attack involves crafting an e-mail that appears legitimate but in fact contains links to fake websites or downloads malicious content. The links contained within the e-mail lead the user to a fake web form in which the information entered is saved for the hacker’s use.
Another successful computer-based social-engineering attack is through the use of chat or messenger channels. Attackers not only use chat channels to find out personal information to employ in future attacks but also make use of the channels to spread malicious code and install software. In fact, Internet Relay Chat (IRC) is the primary way zombies (computers that have been compromised by malicious code and are part of a “bot-net”) are manipulated by their malicious code masters.

Setting up multiple layers of defense—including change management procedures and strong authentication measures—is a good start in mitigating social engineering. Promoting policies and procedures is a good idea as well. Other physical and technical controls can be set up, but the only real defense against social engineering is user edu- cation. Training users—especially those in technical support positions—how to recog- nize and prevent social engineering is the best countermeasure available.

Physical security measures come down to three major components: physical, tech- nical, and operational. Physical measures include all the things you can touch, taste, smell, or get shocked by. For example, lighting, locks, fences, and guards with Tas- ers are all physical measures. Technical measures are implemented as authentication or permissions. For example, firewalls, IDS, and passwords are all technical measures designed to assist with physical security. Operational measures are the policies and procedures you set up to enforce a security-minded operation.

Biometrics includes the measures taken for authentication that come from the “some- thing you are” category. Biometric systems are measured by two main factors. The first, false rejection rate (FRR), is the percentage of time a biometric reader will deny access to a legitimate user. The percentage of time that an unauthorized user is granted access by the system, known as false acceptance rate (FAR), is the second major factor. These are usually graphed on a chart, and the intersecting mark, known as crossover error rate (CER), becomes a ranking method to determine how well the system functions overall.

The man trap, designed as a pure physical access control, provides additional control and screening at the door or access hallway to the controlled area. In the man trap, two doors are used to create a small space to hold a person until appropriate authentication has occurred. The user enters through the first door, which must shut and lock before the second door can be cleared. Once inside the enclosed room, which normally has clear walls, the user must authenticate through some means—biometric, token with pin, password, and so on—to open the second door.


Chapter 11
Security assessments can be one of two types: a security audit (vulnerability assess- ment) or a penetration test. The security audit scans and tests a system or network for existing vulnerabilities but does not intentionally exploit any of them. This assessment is designed to uncover potential security holes in the system and report them to the client for their action. It does not fix or patch vulnerabilities, nor does it exploit them. It only points them out for the client’s benefit.
A penetration test actively seeks to exploit vulnerabilities encountered on target systems or networks. This shows the potential consequences of a hacker breaking in through unpatched vulnerabilities. Penetration tests are carried out by highly skilled individuals according to an agreement signed before testing begins. This agreement spells out the limitations, constraints, and liabilities between the organization and the penetration test team.
Penetration tests consist of two types of assessment: external and internal. An external assessment analyzes publicly available information and conducts network scanning, enumeration, and testing from the network perimeter—usually from the Internet. An internal assessment is performed from within the organization, from various network access points.
Black-box testing occurs when the attacker has no prior knowledge of the infrastruc- ture at all (your scope is defined, and you’ll be provided the minimal amount of information required). This testing takes the longest to accomplish and simulates a true outside hacker. White-box testing simulates an internal user who has complete knowledge of the company’s infrastructure. Gray-box testing provides limited informa- tion on the infrastructure. Sometimes gray-box testing is born out of a black-box test that determines more knowledge is needed.
Testing can also be further broken down according to the way it is accomplished. Automated testing uses an all-inclusive toolset. Automated tools can provide plenty of information and many legitimate results for a lesser price than manual testing with a full test team. However, they are also susceptible to false positives and false negatives and don’t always stop where they’re supposed to (software can’t read your agreement contract). Manual testing is the best choice for security assessment. It requires good planning, design, and scheduling, and it provides the best benefit to the client. Manual testing is accomplished by a pen test team, following the explicit guidelines laid out before the assessment.

There are three main phases to a pen test. In the pre-attack phase, reconnaissance and data gathering efforts are accomplished. Gathering competitive intelligence, identi- fying network ranges, checking network filters for open ports, and so on, are all carried out in this phase. Running whois, DNS enumeration, finding the network IP address range, and nmap network scanning are all examples of tasks in this phase.
 
Attempting to penetrate the network perimeter, acquire your targets, execute attacks, and elevate privileges are steps taken in the attack phase. Verifying ACLs by crafting packets, checking to see whether you can use any covert tunnels inside the organization, and using XSS, buffer overflows, and SQL injections are all examples of tasks performed in this phase. After acquiring specific targets, you’ll move into password cracking and privilege escalation, using a variety of methods. Finally, once you’ve gained access, it’s time to execute your attack code.
The post-attack phase consists of two major steps. The first step involves cleaning up your testing efforts. Anything that has been uploaded to the organization’s systems in the way of files or folders needs to be removed. Any tools, malware, backdoors, or other attack software loaded on the client’s systems need to be taken off. Any registry changes you’ve made need to be reset to their original settings. The goal of this phase is to return everything to the pre-test state.
The second step involves writing the pen test report, due after all testing is complete. The pen test report should contain the following items:
An executive summary of the organization’s overall security posture. (If you’re testing under the auspices of FISMA, DIACAP, HIPAA, or some other standard, this will be tailored to the standard.)
The names of all participants and the dates of all tests.
A list of findings, usually presented in order of highest risk.
An analysis of each finding and the recommended mitigation steps (if available).
Log files and other evidence from your toolset.
----------------------------------------------------------------
ARP spoofing, ARP cache poisoning, or ARP poison routing, is a technique by which an attacker sends (spoofed) Address Resolution Protocol (ARP) messages onto a local area network. Generally, the aim is to associate the attacker's MAC address with the IP address of another host, such as thedefault gateway, causing any traffic meant for that IP address to be sent to the attacker instead.
ARP spoofing may allow an attacker to intercept data frames on a network, modify the traffic, or stop all traffic. Often the attack is used as an opening for other attacks, such as denial of service, man in the middle, orsession hijacking attacks.[1]
The attack can only be used on networks that use the Address Resolution Protocol, and is limited to local network segments
Private VLAN, also known as port isolation, is a technique in computer networking where a VLAN contains switch ports that are restricted such that they can only communicate with a given "uplink". The restricted ports are called "private ports". Each private VLAN typically contains many private ports, and a single uplink. The uplink will typically be a port (or link aggregation group) connected to a router, firewall, server, provider network, or similar central resource.
The switch forwards all frames received from a private port to the uplink port, regardless of VLAN ID or destination MAC address. Frames received from an uplink port are forwarded in the normal way (i.e. to the port hosting the destination MAC address, or to all ports of the VLAN for broadcast frames or for unknown destination MAC addresses). As a result, direct peer-to-peer traffic between peers through the switch is blocked, and any such communication must go through the uplink. While private VLANs provide isolation between peers at the data link layer, communication at higher layers may still be possible depending on further network configuration.
